use bon::bon;
pub use num_traits::identities::Zero;
use std::ops::Add;

/// The source of a [`WireEvent`].
#[derive(Clone, Copy, Debug)]
pub enum Source {
    /// The first avalanche from a cosmic event.
    PrimaryCosmic,
    /// Secondary avalanches in a cosmic event. Generated by electrons
    /// originally produced in the drift region of the rTPC.
    SecondaryCosmic,
    /// The first avalanche from an anti-proton event.
    PrimaryPbar,
    /// Secondary avalanches in an anti-proton event. Generated by electrons
    /// originally produced in the drift region of the rTPC.
    SecondaryPbar,
    /// Noise events.
    Noise,
}

/// A [`WireEvent`] represents an input signal to the trigger system.
///
/// The digitized anode wire waveforms go into digital discriminators. This
/// discriminator outputs ([`WireEvent`]s) are then sent to the trigger system.
#[derive(Clone, Copy, Debug)]
pub struct WireEvent<F> {
    pub source: Source,
    pub time: F,
}

/// A value that is known to be greater than zero.
#[derive(Clone, Copy, Debug, PartialEq, PartialOrd)]
pub struct Positive<F>(F);

impl<F> Positive<F>
where
    F: Zero + PartialOrd,
{
    pub fn new(value: F) -> Option<Self> {
        if value > F::zero() {
            Some(Self(value))
        } else {
            None
        }
    }
}

/// Generator of positive values.
pub trait InterArrivalTime {
    /// The type of the inter-arrival time.
    type Item;
    fn next(&mut self) -> Option<Positive<Self::Item>>;
}

impl<F, I> InterArrivalTime for I
where
    I: Iterator<Item = Positive<F>>,
{
    type Item = F;

    fn next(&mut self) -> Option<Positive<F>> {
        self.next()
    }
}

/// Generator of [`WireEvent`]s.
pub trait EventGenerator {
    /// The type of the time.
    type Time;
    fn next_event(&mut self) -> Option<WireEvent<Self::Time>>;
}

/// A generator of [`WireEvent`]s without afterpulses.
///
/// The generator produces a stream of [`WireEvent`]s all with the same source.
/// All events are guaranteed to be in increasing order of time. A generator
/// stops producing events when either the maximum time is reached or when the
/// inter-arrival time distribution is exhausted.
#[derive(Clone, Debug)]
pub struct SecondaryGenerator<F, I> {
    source: Source,
    next_time: Option<F>,
    max_time: Option<F>,
    inter_arrival_time: I,
}

#[bon]
impl<F, I> SecondaryGenerator<F, I> {
    #[builder]
    pub fn new(source: Source, origin: F, max_time: Option<F>, inter_arrival_time: I) -> Self
    where
        F: PartialOrd + for<'a> Add<&'a F, Output = F>,
        I: InterArrivalTime<Item = F>,
    {
        let mut inter_arrival_time = inter_arrival_time;

        let next_time = match (inter_arrival_time.next(), &max_time) {
            (Some(Positive(t)), Some(max_t)) => {
                let next_time = origin + &t;
                if next_time < *max_t {
                    Some(next_time)
                } else {
                    None
                }
            }
            (Some(Positive(t)), None) => Some(origin + &t),
            (None, _) => None,
        };

        Self {
            source,
            next_time,
            max_time,
            inter_arrival_time,
        }
    }
}

impl<F, I> EventGenerator for SecondaryGenerator<F, I>
where
    F: PartialOrd + for<'a> Add<&'a F, Output = F>,
    I: InterArrivalTime<Item = F>,
{
    type Time = F;

    fn next_event(&mut self) -> Option<WireEvent<Self::Time>> {
        match (self.next_time.take(), self.inter_arrival_time.next()) {
            (Some(time), Some(Positive(delta_t))) => {
                let next_time = delta_t + &time;
                if let Some(max_time) = &self.max_time {
                    if next_time < *max_time {
                        self.next_time = Some(next_time);
                    }
                }

                Some(WireEvent {
                    source: self.source,
                    time,
                })
            }
            (Some(time), None) => Some(WireEvent {
                source: self.source,
                time,
            }),
            (None, _) => None,
        }
    }
}

impl<F, I> Iterator for SecondaryGenerator<F, I>
where
    F: PartialOrd + for<'a> Add<&'a F, Output = F>,
    I: InterArrivalTime<Item = F>,
{
    type Item = WireEvent<F>;

    fn next(&mut self) -> Option<Self::Item> {
        self.next_event()
    }
}

/// A generator of [`WireEvent`]s supporting afterpulses.
#[derive(Clone, Debug)]
pub struct PrimaryGenerator<F, I1, B, I2> {
    primary: SecondaryGenerator<F, I1>,

    afterpulse: B,
    secondaries: Vec<SecondaryGenerator<F, I2>>,
}

#[bon]
impl<F, I1, B, I2> PrimaryGenerator<F, I1, B, I2> {
    #[builder]
    pub fn new(
        source: Source,
        origin: F,
        max_time: Option<F>,
        inter_arrival_time: I1,
        afterpulse: B,
    ) -> Self
    where
        F: PartialOrd + for<'a> Add<&'a F, Output = F>,
        I1: InterArrivalTime<Item = F>,
    {
        let primary = SecondaryGenerator::builder()
            .source(source)
            .origin(origin)
            .maybe_max_time(max_time)
            .inter_arrival_time(inter_arrival_time)
            .build();

        Self {
            primary,
            afterpulse,
            secondaries: Vec::new(),
        }
    }
}

use secondary_generator_builder::{IsSet, IsUnset, State};

impl<F, I1, B, I2, S: State> EventGenerator for PrimaryGenerator<F, I1, B, I2>
where
    F: PartialOrd + for<'a> Add<&'a F, Output = F> + Clone,
    I1: InterArrivalTime<Item = F>,
    B: FnMut(&WireEvent<F>) -> SecondaryGeneratorBuilder<F, I2, S>,
    I2: InterArrivalTime<Item = F>,
    S::Source: IsSet,
    S::Origin: IsUnset,
    S::InterArrivalTime: IsSet,
{
    type Time = F;

    fn next_event(&mut self) -> Option<WireEvent<Self::Time>> {
        if let Some(index) = self
            .secondaries
            .iter()
            .enumerate()
            .min_by(|(_, a), (_, b)| {
                // Unwrap is safe because (given the InterArrivalTime trait) we
                // don't have NaNs.
                a.next_time.partial_cmp(&b.next_time).unwrap()
            })
            .map(|(i, _)| i)
        {
            todo!()
        } else if let Some(next_event) = self.primary.next_event() {
            let generator = (self.afterpulse)(&next_event)
                .origin(next_event.time.clone())
                .build();
            self.secondaries.push(generator);

            Some(next_event)
        } else {
            None
        }
    }
}

impl<F, I1, B, I2, S: State> Iterator for PrimaryGenerator<F, I1, B, I2>
where
    F: PartialOrd + for<'a> Add<&'a F, Output = F> + Clone,
    I1: InterArrivalTime<Item = F>,
    B: FnMut(&WireEvent<F>) -> SecondaryGeneratorBuilder<F, I2, S>,
    I2: InterArrivalTime<Item = F>,
    S::Source: IsSet,
    S::Origin: IsUnset,
    S::InterArrivalTime: IsSet,
{
    type Item = WireEvent<F>;

    fn next(&mut self) -> Option<Self::Item> {
        self.next_event()
    }
}
