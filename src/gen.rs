use bon::bon;
pub use num_traits::identities::Zero;

/// The source of a [`WireEvent`].
#[derive(Clone, Copy, Debug)]
pub enum Source {
    /// The first avalanche from a cosmic event.
    PrimaryCosmic,
    /// Secondary avalanches in a cosmic event. Generated by electrons
    /// originally produced in the drift region of the rTPC.
    SecondaryCosmic,
    /// The first avalanche from an anti-proton event.
    PrimaryPbar,
    /// Secondary avalanches in an anti-proton event. Generated by electrons
    /// originally produced in the drift region of the rTPC.
    SecondaryPbar,
    /// Noise events.
    Noise,
}

/// A [`WireEvent`] represents an input signal to the trigger system.
///
/// The digitized anode wire waveforms go into digital discriminators. This
/// discriminator outputs ([`WireEvent`]s) are then sent to the trigger system.
#[derive(Clone, Copy, Debug)]
pub struct WireEvent<F> {
    pub source: Source,
    pub time: F,
}

/// A value that is known to be greater than zero.
#[derive(Clone, Copy, Debug, PartialEq, PartialOrd)]
pub struct Positive<F>(F);

impl<F> Positive<F>
where
    F: Zero + PartialOrd,
{
    pub fn new(value: F) -> Option<Self> {
        if value > F::zero() {
            Some(Self(value))
        } else {
            None
        }
    }
}

/// A generator of [`WireEvent`]s.
///
/// The generator produces a stream of [`WireEvent`]s all with the same source.
/// All events are guaranteed to be in increasing order of time. A generator
/// stops producing events when either the maximum time is reached or when the
/// inter-arrival time distribution is exhausted.
#[derive(Clone, Debug)]
pub struct Generator<F, T, G> {
    source: Source,
    max_time: Option<F>,
    inter_arrival_time: T,
    afterpulse: G,
}

#[bon]
impl<F, T, G> Generator<F, T, G> {
    #[builder]
    pub fn new<I>(source: Source, max_time: Option<F>, inter_arrival_time: I, afterpulse: G) -> Self
    where
        I: IntoIterator<IntoIter = T>,
    {
        Self {
            source,
            max_time,
            inter_arrival_time: inter_arrival_time.into_iter(),
            afterpulse,
        }
    }
}

impl<F, T, G, O> Iterator for Generator<F, T, G>
where
    T: Iterator<Item = Positive<F>>,
    G: FnMut(&WireEvent<F>) -> O,
    O: IntoIterator<Item = WireEvent<F>>,
{
    type Item = WireEvent<F>;

    fn next(&mut self) -> Option<Self::Item> {
        todo!()
    }
}
