use bon::bon;
pub use num_traits::identities::Zero;
use std::ops::Add;

/// The source of a [`WireEvent`].
#[derive(Clone, Copy, Debug)]
pub enum Source {
    /// The first avalanche from a cosmic event.
    PrimaryCosmic,
    /// Secondary avalanches in a cosmic event. Generated by electrons
    /// originally produced in the drift region of the rTPC.
    SecondaryCosmic,
    /// The first avalanche from an anti-proton event.
    PrimaryPbar,
    /// Secondary avalanches in an anti-proton event. Generated by electrons
    /// originally produced in the drift region of the rTPC.
    SecondaryPbar,
    /// Noise events.
    Noise,
}

/// A [`WireEvent`] represents an input signal to the trigger system.
///
/// The digitized anode wire waveforms go into digital discriminators. This
/// discriminator outputs ([`WireEvent`]s) are then sent to the trigger system.
#[derive(Clone, Copy, Debug)]
pub struct WireEvent<F> {
    pub source: Source,
    pub time: F,
}

/// A value that is known to be greater than zero.
#[derive(Clone, Copy, Debug, PartialEq, PartialOrd)]
pub struct Positive<F>(F);

impl<F> Positive<F>
where
    F: Zero + PartialOrd,
{
    pub fn new(value: F) -> Option<Self> {
        if value > F::zero() {
            Some(Self(value))
        } else {
            None
        }
    }
}

#[derive(Clone, Copy, Debug)]
struct SecondaryGen<F, O> {
    next_event: WireEvent<F>,
    iter: O,
}

/// A generator of [`WireEvent`]s.
///
/// The generator produces a stream of [`WireEvent`]s all with the same source.
/// All events are guaranteed to be in increasing order of time. A generator
/// stops producing events when either the maximum time is reached or when the
/// inter-arrival time distribution is exhausted.
#[derive(Clone, Debug)]
pub struct Generator<F, T, G, O> {
    source: Source,
    max_time: Option<F>,
    inter_arrival_time: T,
    afterpulse: G,

    // Keeping track of the inner state this way (both for primary and
    // secondary events) allows us to handle e.g. infinite secondary generators
    // because we don't have to completely collect them before producing another
    // primary event.
    next_event: Option<WireEvent<F>>,
    secondaries: Vec<SecondaryGen<F, O>>,
}

#[bon]
impl<F, T, G, O> Generator<F, T, G, O> {
    #[builder]
    pub fn new<I>(source: Source, max_time: Option<F>, inter_arrival_time: I, afterpulse: G) -> Self
    where
        // `F: Default + Add<Output = F>` is another option, but given that
        // `Zero` is already a requirement to build a `Positive<F>`, it seems
        // more appropriate.
        F: Zero + PartialOrd,
        I: IntoIterator<IntoIter = T>,
        T: Iterator<Item = Positive<F>>,
    {
        let mut inter_arrival_time = inter_arrival_time.into_iter();

        let next_event = match (inter_arrival_time.next(), &max_time) {
            (Some(Positive(time)), Some(max_t)) => {
                if time < *max_t {
                    Some(WireEvent { source, time })
                } else {
                    None
                }
            }
            (Some(Positive(time)), None) => Some(WireEvent { source, time }),
            (None, _) => None,
        };

        Self {
            source,
            max_time,
            inter_arrival_time,
            afterpulse,
            next_event,
            secondaries: Vec::new(),
        }
    }
}

impl<F, T, G, O> Iterator for Generator<F, T, G, O>
where
    // We don't need a full `Ord` implementation because `Positive<F>` already
    // guarantees that the value is greater than zero (e.g. no NaNs could get
    // here).
    F: PartialOrd + for<'a> Add<&'a F, Output = F>,
    T: Iterator<Item = Positive<F>>,
    G: FnMut(&WireEvent<F>) -> O,
    O: Iterator<Item = WireEvent<F>>,
{
    type Item = WireEvent<F>;

    fn next(&mut self) -> Option<Self::Item> {
        if let Some(index) = self
            .secondaries
            .iter()
            .enumerate()
            .min_by(|(_, a), (_, b)| {
                // Unwrap is safe for the same reason we only ask `PartialOrd`
                a.next_event.time.partial_cmp(&b.next_event.time).unwrap()
            })
            .map(|(i, _)| i)
        {
            let next_secondary = &self.secondaries[index];
            todo!()
        } else {
            match (self.next_event.take(), self.inter_arrival_time.next()) {
                (Some(event), Some(Positive(t))) => {
                    let next_time = t + &event.time;
                    if let Some(max_time) = &self.max_time {
                        if next_time < *max_time {
                            self.next_event = Some(WireEvent {
                                source: self.source,
                                time: next_time,
                            });
                        }
                    }

                    Some(event)
                }
                (Some(event), None) => Some(event),
                (None, _) => None,
            }
        }
    }
}
