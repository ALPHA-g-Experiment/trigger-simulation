use bon::bon;
pub use num_traits::identities::Zero;
use std::ops::Add;

/// The source of a [`WireEvent`].
#[derive(Clone, Copy, Debug)]
pub enum Source {
    /// The first avalanche from a cosmic event.
    PrimaryCosmic,
    /// Secondary avalanches in a cosmic event. Generated by electrons
    /// originally produced in the drift region of the rTPC.
    SecondaryCosmic,
    /// The first avalanche from an anti-proton event.
    PrimaryPbar,
    /// Secondary avalanches in an anti-proton event. Generated by electrons
    /// originally produced in the drift region of the rTPC.
    SecondaryPbar,
    /// Noise events.
    Noise,
}

/// A [`WireEvent`] represents an input signal to the trigger system.
///
/// The digitized anode wire waveforms go into digital discriminators. This
/// discriminator outputs ([`WireEvent`]s) are then sent to the trigger system.
#[derive(Clone, Copy, Debug)]
pub struct WireEvent<F> {
    pub source: Source,
    pub time: F,
}

/// A value that is known to be greater than zero.
#[derive(Clone, Copy, Debug, PartialEq, PartialOrd)]
pub struct Positive<F>(F);

impl<F> Positive<F>
where
    F: Zero + PartialOrd,
{
    pub fn new(value: F) -> Option<Self> {
        if value > F::zero() {
            Some(Self(value))
        } else {
            None
        }
    }
}

mod sealed {
    pub trait OrderedIterator: Iterator {}
}

/// Generator of [`WireEvent`]s.
///
/// Events are guaranteed to be produced in increasing order of time.
pub trait EventGenerator: sealed::OrderedIterator<Item = WireEvent<Self::Time>> {
    type Time;
}

impl<T, G> EventGenerator for G
where
    G: sealed::OrderedIterator<Item = WireEvent<T>>,
{
    type Time = T;
}

/// A generator of [`WireEvent`]s without afterpulses.
///
/// The generator produces a stream of [`WireEvent`]s all with the same
/// [`Source`]. A generator stops producing events when either it has exhausted
/// the inter-arrival time distribution or the desired duration has been
/// reached.
#[derive(Clone, Debug)]
pub struct SecondaryGenerator<F, I> {
    source: Source,
    // Another alternative is to use a `current_time` instead. But I noticed
    // that fetching the next event is needed basically everywhere (to e.g.
    // check which of a set of generators is next). So it makes it easier to
    // work with in the end.
    next_time: Option<F>,
    max_time: Option<F>,
    inter_arrival_time: I,
}

#[bon]
impl<F, I> SecondaryGenerator<F, I> {
    #[builder]
    pub fn new<T>(
        /// The source of the generated events.
        source: Source,
        /// The time at which the generator starts producing events. Note that
        /// the first event is produced at `origin` + `delta_t`, where `delta_t`
        /// is the first value produced by `inter_arrival_time`.
        origin: F,
        /// Length of time the generator produces events for. All events are
        /// guaranteed to have a time less than `origin` + `duration`.
        duration: Option<Positive<F>>,
        /// The distribution of inter-arrival times between events.
        inter_arrival_time: T,
    ) -> Self
    where
        F: PartialOrd + for<'a> Add<&'a F, Output = F>,
        T: IntoIterator<IntoIter = I>,
        I: Iterator<Item = Positive<F>>,
    {
        let mut inter_arrival_time = inter_arrival_time.into_iter();

        let next_time = match (inter_arrival_time.next(), &duration) {
            (Some(Positive(t)), Some(Positive(limit))) => {
                if t < *limit {
                    Some(t + &origin)
                } else {
                    None
                }
            }
            (Some(Positive(t)), None) => Some(t + &origin),
            (None, _) => None,
        };
        let max_time = duration.map(|Positive(t)| t + &origin);

        Self {
            source,
            next_time,
            max_time,
            inter_arrival_time,
        }
    }
}

impl<F, I> Iterator for SecondaryGenerator<F, I>
where
    F: PartialOrd + for<'a> Add<&'a F, Output = F>,
    I: Iterator<Item = Positive<F>>,
{
    type Item = WireEvent<F>;

    fn next(&mut self) -> Option<Self::Item> {
        match (self.next_time.take(), self.inter_arrival_time.next()) {
            (Some(time), Some(Positive(delta_t))) => {
                let next_time = delta_t + &time;
                if let Some(max_time) = &self.max_time {
                    if next_time < *max_time {
                        self.next_time = Some(next_time);
                    }
                } else {
                    self.next_time = Some(next_time);
                }

                Some(WireEvent {
                    source: self.source,
                    time,
                })
            }
            (Some(time), None) => Some(WireEvent {
                source: self.source,
                time,
            }),
            (None, _) => None,
        }
    }
}

impl<F, I> sealed::OrderedIterator for SecondaryGenerator<F, I>
where
    F: PartialOrd + for<'a> Add<&'a F, Output = F>,
    I: Iterator<Item = Positive<F>>,
{
}

/// A generator of [`WireEvent`]s with afterpulses.
///
/// The generator produces a stream of [`WireEvent`]s in increasing order of
/// time. Each primary event triggers a set of secondary events. The generator
/// stops when all primary and secondary events have been produced.
#[derive(Clone, Debug)]
pub struct PrimaryGenerator<F, I1, B, I2> {
    primary: SecondaryGenerator<F, I1>,

    afterpulse: B,
    secondaries: Vec<SecondaryGenerator<F, I2>>,
}

#[bon]
impl<F, I1, B, I2> PrimaryGenerator<F, I1, B, I2> {
    #[builder]
    pub fn new<T1>(
        /// The source of the primary events.
        source: Source,
        /// The time at which the generator starts producing events. Note that
        /// the first event is produced at `origin` + `delta_t`, where `delta_t`
        /// is the first value produced by `inter_arrival_time`.
        origin: F,
        /// Length of time the generator produces primary events for. Note that
        /// the generator will keep producing secondary events until all
        /// secondary generators have also been exhausted (which could be after
        /// the primary generator has stopped producing events).
        duration: Option<Positive<F>>,
        /// The distribution of inter-arrival times between primary events.
        inter_arrival_time: T1,
        /// Secondary generator builder.
        ///
        /// The `origin` of the secondary generator is automatically set to the
        /// time of the primary event that triggered it.
        afterpulse: B,
    ) -> Self
    where
        F: PartialOrd + for<'a> Add<&'a F, Output = F>,
        T1: IntoIterator<IntoIter = I1>,
        I1: Iterator<Item = Positive<F>>,
    {
        let primary = SecondaryGenerator::builder()
            .source(source)
            .origin(origin)
            .maybe_duration(duration)
            .inter_arrival_time(inter_arrival_time)
            .build();

        Self {
            primary,
            afterpulse,
            secondaries: Vec::new(),
        }
    }
}

use secondary_generator_builder::{IsSet, IsUnset, State};

impl<F, I1, B, I2, T2, S: State> PrimaryGenerator<F, I1, B, I2>
where
    F: PartialOrd + for<'a> Add<&'a F, Output = F> + Clone,
    I1: Iterator<Item = Positive<F>>,
    B: FnMut(&WireEvent<F>) -> SecondaryGeneratorBuilder<F, I2, T2, S>,
    T2: IntoIterator<IntoIter = I2>,
    I2: Iterator<Item = Positive<F>>,
    S::Source: IsSet,
    S::Origin: IsUnset,
    S::InterArrivalTime: IsSet,
{
    fn next_primary(&mut self) -> Option<WireEvent<F>> {
        if let Some(next_event) = self.primary.next() {
            let generator = (self.afterpulse)(&next_event)
                .origin(next_event.time.clone())
                .build();
            // Only keep around secondary generators that have something to
            // produce.
            if generator.next_time.is_some() {
                self.secondaries.push(generator);
            }

            Some(next_event)
        } else {
            None
        }
    }

    fn next_secondary(&mut self, index: usize) -> WireEvent<F> {
        // Unwrap is safe because we only keep around generators that have
        // something to produce.
        let next_event = self.secondaries[index].next().unwrap();
        // Only keep around secondary generators that have something to produce.
        if self.secondaries[index].next_time.is_none() {
            self.secondaries.swap_remove(index);
        }

        next_event
    }
}

impl<F, I1, B, I2, T2, S: State> Iterator for PrimaryGenerator<F, I1, B, I2>
where
    F: PartialOrd + for<'a> Add<&'a F, Output = F> + Clone,
    I1: Iterator<Item = Positive<F>>,
    B: FnMut(&WireEvent<F>) -> SecondaryGeneratorBuilder<F, I2, T2, S>,
    T2: IntoIterator<IntoIter = I2>,
    I2: Iterator<Item = Positive<F>>,
    S::Source: IsSet,
    S::Origin: IsUnset,
    S::InterArrivalTime: IsSet,
{
    type Item = WireEvent<F>;

    fn next(&mut self) -> Option<Self::Item> {
        if let Some(index) = self
            .secondaries
            .iter()
            .enumerate()
            .min_by(|(_, a), (_, b)| {
                // Unwrap is safe because (given the PositiveIterator trait) we
                // don't have NaNs.
                a.next_time.partial_cmp(&b.next_time).unwrap()
            })
            .map(|(i, _)| i)
        {
            if let Some(next_primary) = &self.primary.next_time {
                // Unwrap is safe because we only keep around secondary
                // generators that have something to produce.
                if next_primary < self.secondaries[index].next_time.as_ref().unwrap() {
                    self.next_primary()
                } else {
                    Some(self.next_secondary(index))
                }
            } else {
                Some(self.next_secondary(index))
            }
        } else {
            self.next_primary()
        }
    }
}

impl<F, I1, B, I2, T2, S: State> sealed::OrderedIterator for PrimaryGenerator<F, I1, B, I2>
where
    F: PartialOrd + for<'a> Add<&'a F, Output = F> + Clone,
    I1: Iterator<Item = Positive<F>>,
    B: FnMut(&WireEvent<F>) -> SecondaryGeneratorBuilder<F, I2, T2, S>,
    T2: IntoIterator<IntoIter = I2>,
    I2: Iterator<Item = Positive<F>>,
    S::Source: IsSet,
    S::Origin: IsUnset,
    S::InterArrivalTime: IsSet,
{
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::iter::repeat;

    #[test]
    fn positive_new() {
        assert_eq!(Positive::new(0.0), None);
        assert_eq!(Positive::new(-1.0), None);
        assert_eq!(Positive::new(1.0), Some(Positive(1.0)));
    }

    #[test]
    fn secondary_generator_source() {
        let gen = SecondaryGenerator::builder()
            .source(Source::Noise)
            .origin(0.0)
            .inter_arrival_time(vec![Positive::new(1.0).unwrap()])
            .build();

        for event in gen {
            assert!(matches!(event.source, Source::Noise));
        }
    }

    #[test]
    fn secondary_generator_origin() {
        let mut gen = SecondaryGenerator::builder()
            .source(Source::Noise)
            .origin(-10.0)
            .inter_arrival_time(vec![Positive::new(1.0).unwrap()])
            .build();

        assert_eq!(gen.next().unwrap().time, -9.0);
    }

    #[test]
    fn secondary_generator_duration() {
        let events = SecondaryGenerator::builder()
            .source(Source::Noise)
            .origin(0.0)
            .duration(Positive::new(10.0).unwrap())
            .inter_arrival_time(repeat(Positive::new(1.0).unwrap()))
            .build()
            .collect::<Vec<_>>();

        assert_eq!(events.last().unwrap().time, 9.0);
    }

    #[test]
    fn secondary_generator_inter_arrival_time() {
        let mut gen = SecondaryGenerator::builder()
            .source(Source::Noise)
            .origin(0.0)
            .inter_arrival_time(vec![
                Positive::new(1.0).unwrap(),
                Positive::new(2.0).unwrap(),
            ])
            .build();

        assert_eq!(gen.next().unwrap().time, 1.0);
        assert_eq!(gen.next().unwrap().time, 3.0);
        assert!(gen.next().is_none());
    }

    #[test]
    fn primary_generator_source() {
        let mut gen = PrimaryGenerator::builder()
            .source(Source::PrimaryPbar)
            .origin(0.0)
            .inter_arrival_time(vec![Positive::new(1.0).unwrap()])
            .afterpulse(|_: &_| {
                SecondaryGenerator::builder()
                    .source(Source::SecondaryPbar)
                    .inter_arrival_time(vec![Positive::new(1.0).unwrap()])
            })
            .build();

        assert!(matches!(gen.next().unwrap().source, Source::PrimaryPbar));
        assert!(matches!(gen.next().unwrap().source, Source::SecondaryPbar));
    }

    #[test]
    fn primary_generator_origin() {
        let mut gen = PrimaryGenerator::builder()
            .source(Source::PrimaryPbar)
            .origin(0.0)
            .inter_arrival_time(vec![Positive::new(1.0).unwrap()])
            .afterpulse(|_: &_| {
                SecondaryGenerator::builder()
                    .source(Source::SecondaryPbar)
                    .inter_arrival_time(vec![Positive::new(1.0).unwrap()])
            })
            .build();

        assert_eq!(gen.next().unwrap().time, 1.0);
    }

    #[test]
    fn primary_generator_duration() {
        let events = PrimaryGenerator::builder()
            .source(Source::PrimaryPbar)
            .origin(0.0)
            .duration(Positive::new(10.0).unwrap())
            .inter_arrival_time(repeat(Positive::new(1.0).unwrap()))
            .afterpulse(|_: &_| {
                SecondaryGenerator::builder()
                    .source(Source::SecondaryPbar)
                    .inter_arrival_time(vec![Positive::new(1.0).unwrap()])
            })
            .build()
            .collect::<Vec<_>>();

        assert_eq!(
            events
                .iter()
                .filter(|e| matches!(e.source, Source::PrimaryPbar))
                .last()
                .unwrap()
                .time,
            9.0
        );
        assert_eq!(events.last().unwrap().time, 10.0);
    }

    #[test]
    fn primary_generator_inter_arrival_time() {
        let mut gen = PrimaryGenerator::builder()
            .source(Source::PrimaryPbar)
            .origin(0.0)
            .inter_arrival_time(vec![
                Positive::new(1.0).unwrap(),
                Positive::new(2.0).unwrap(),
            ])
            .afterpulse(|_: &_| {
                SecondaryGenerator::builder()
                    .source(Source::SecondaryPbar)
                    .inter_arrival_time(vec![Positive::new(0.1).unwrap()])
            })
            .build()
            .filter(|e| matches!(e.source, Source::PrimaryPbar));

        assert_eq!(gen.next().unwrap().time, 1.0);
        assert_eq!(gen.next().unwrap().time, 3.0);
        assert!(gen.next().is_none());
    }

    #[test]
    fn primary_generator_afterpulse() {
        let mut count = 0;

        let mut gen = PrimaryGenerator::builder()
            .source(Source::PrimaryPbar)
            .origin(0.0)
            .inter_arrival_time(repeat(Positive::new(1.0).unwrap()).take(3))
            .afterpulse(|_: &_| {
                let n = count;
                let delta_t = 1.0 / (n + 1) as f64;
                count += 1;

                SecondaryGenerator::builder()
                    .source(Source::SecondaryPbar)
                    .inter_arrival_time(repeat(Positive::new(delta_t).unwrap()).take(n))
            })
            .build();

        assert!((gen.next().unwrap().time - 1.0).abs() < 1e-6);
        assert!((gen.next().unwrap().time - 2.0).abs() < 1e-6);
        assert!((gen.next().unwrap().time - 2.5).abs() < 1e-6);
        assert!((gen.next().unwrap().time - 3.0).abs() < 1e-6);
        assert!((gen.next().unwrap().time - 10.0 / 3.0).abs() < 1e-6);
        assert!((gen.next().unwrap().time - 11.0 / 3.0).abs() < 1e-6);
        assert!(gen.next().is_none());
    }
}
