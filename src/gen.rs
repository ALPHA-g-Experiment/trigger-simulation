use bon::bon;
pub use num_traits::identities::Zero;
use std::ops::Add;

/// The source of a [`WireEvent`].
#[derive(Clone, Copy, Debug)]
pub enum Source {
    /// The first avalanche from a cosmic event.
    PrimaryCosmic,
    /// Secondary avalanches in a cosmic event. Generated by electrons
    /// originally produced in the drift region of the rTPC.
    SecondaryCosmic,
    /// The first avalanche from an anti-proton event.
    PrimaryPbar,
    /// Secondary avalanches in an anti-proton event. Generated by electrons
    /// originally produced in the drift region of the rTPC.
    SecondaryPbar,
    /// Noise events.
    Noise,
}

/// A [`WireEvent`] represents an input signal to the trigger system.
///
/// The digitized anode wire waveforms go into digital discriminators. This
/// discriminator outputs ([`WireEvent`]s) are then sent to the trigger system.
#[derive(Clone, Copy, Debug)]
pub struct WireEvent<F> {
    pub source: Source,
    pub time: F,
}

/// A value that is known to be greater than zero.
#[derive(Clone, Copy, Debug, PartialEq, PartialOrd)]
pub struct Positive<F>(F);

impl<F> Positive<F>
where
    F: Zero + PartialOrd,
{
    pub fn new(value: F) -> Option<Self> {
        if value > F::zero() {
            Some(Self(value))
        } else {
            None
        }
    }
}

/// A trait for dealing with iterators that produce positive values.
pub trait PositiveIterator {
    /// The type of the positive value.
    type Item;

    fn next_positive(&mut self) -> Option<Positive<Self::Item>>;
}

/// Conversion into a [`PositiveIterator`].
pub trait IntoPositiveIterator {
    /// The type of the positive value.
    type Item;
    /// Which kind of positive iterator are we turning this into?
    type IntoPosIter: PositiveIterator<Item = Self::Item>;

    fn into_pos_iter(self) -> Self::IntoPosIter;
}

impl<I, F> PositiveIterator for I
where
    I: Iterator<Item = Positive<F>>,
{
    type Item = F;

    fn next_positive(&mut self) -> Option<Positive<F>> {
        self.next()
    }
}

impl<T, I, F> IntoPositiveIterator for T
where
    T: IntoIterator<IntoIter = I>,
    I: Iterator<Item = Positive<F>>,
{
    type Item = F;
    type IntoPosIter = I;

    fn into_pos_iter(self) -> Self::IntoPosIter {
        self.into_iter()
    }
}

mod sealed {
    pub trait Sealed {}
}

// I don't see any reason to allow users downstream to implement this trait.
// Re-evaluate if there's a good reason to do so. But its easier to prevent
// misuse by sealing the trait.
/// Generator of [`WireEvent`]s.
///
/// Events are guaranteed to be produced in increasing order of time.
pub trait EventGenerator: sealed::Sealed {
    type Time;
    fn next_event(&mut self) -> Option<WireEvent<Self::Time>>;
}

/// A generator of [`WireEvent`]s without afterpulses.
///
/// The generator produces a stream of [`WireEvent`]s all with the same
/// [`Source`]. A generator stops producing events when either it has exhausted
/// the inter-arrival time distribution or the desired duration has been
/// reached.
#[derive(Clone, Debug)]
pub struct SecondaryGenerator<F, I> {
    source: Source,
    // Another alternative is to use a `current_time` instead. But I noticed
    // that fetching the next event is needed basically everywhere (to e.g.
    // check which of a set of generators is next). So it makes it easier to
    // work with in the end.
    next_time: Option<F>,
    max_time: Option<F>,
    inter_arrival_time: I,
}

#[bon]
impl<F, I> SecondaryGenerator<F, I> {
    #[builder]
    pub fn new<T>(
        /// The source of the generated events.
        source: Source,
        /// The time at which the generator starts producing events. Note that
        /// the first event is produced at `origin` + `delta_t`, where `delta_t`
        /// is the first value produced by `inter_arrival_time`.
        origin: F,
        /// Length of time the generator produces events for. All events are
        /// guaranteed to have a time less than `origin` + `duration`.
        duration: Option<Positive<F>>,
        /// The distribution of inter-arrival times between events.
        inter_arrival_time: T,
    ) -> Self
    where
        F: PartialOrd + for<'a> Add<&'a F, Output = F>,
        T: IntoPositiveIterator<IntoPosIter = I>,
        I: PositiveIterator<Item = F>,
    {
        let mut inter_arrival_time = inter_arrival_time.into_pos_iter();

        let next_time = match (inter_arrival_time.next_positive(), &duration) {
            (Some(Positive(t)), Some(Positive(limit))) => {
                if t < *limit {
                    Some(t + &origin)
                } else {
                    None
                }
            }
            (Some(Positive(t)), None) => Some(t + &origin),
            (None, _) => None,
        };
        let max_time = duration.map(|Positive(t)| t + &origin);

        Self {
            source,
            next_time,
            max_time,
            inter_arrival_time,
        }
    }
}

impl<F, I> sealed::Sealed for SecondaryGenerator<F, I> {}

impl<F, I> EventGenerator for SecondaryGenerator<F, I>
where
    F: PartialOrd + for<'a> Add<&'a F, Output = F>,
    I: PositiveIterator<Item = F>,
{
    type Time = F;

    fn next_event(&mut self) -> Option<WireEvent<Self::Time>> {
        match (
            self.next_time.take(),
            self.inter_arrival_time.next_positive(),
        ) {
            (Some(time), Some(Positive(delta_t))) => {
                let next_time = delta_t + &time;
                if let Some(max_time) = &self.max_time {
                    if next_time < *max_time {
                        self.next_time = Some(next_time);
                    }
                } else {
                    self.next_time = Some(next_time);
                }

                Some(WireEvent {
                    source: self.source,
                    time,
                })
            }
            (Some(time), None) => Some(WireEvent {
                source: self.source,
                time,
            }),
            (None, _) => None,
        }
    }
}

impl<F, I> Iterator for SecondaryGenerator<F, I>
where
    F: PartialOrd + for<'a> Add<&'a F, Output = F>,
    I: PositiveIterator<Item = F>,
{
    type Item = WireEvent<F>;

    fn next(&mut self) -> Option<Self::Item> {
        self.next_event()
    }
}

/*
/// A generator of [`WireEvent`]s supporting afterpulses.
#[derive(Clone, Debug)]
pub struct PrimaryGenerator<F, I1, B, I2> {
    primary: SecondaryGenerator<F, I1>,

    afterpulse: B,
    secondaries: Vec<SecondaryGenerator<F, I2>>,
}

impl<F, I1, B, I2> sealed::Sealed for PrimaryGenerator<F, I1, B, I2> {}

#[bon]
impl<F, I1, B, I2> PrimaryGenerator<F, I1, B, I2> {
    #[builder]
    pub fn new(
        source: Source,
        origin: F,
        max_time: Option<F>,
        inter_arrival_time: I1,
        afterpulse: B,
    ) -> Self
    where
        F: PartialOrd + for<'a> Add<&'a F, Output = F>,
        I1: PositiveIterator<Item = F>,
    {
        let primary = SecondaryGenerator::builder()
            .source(source)
            .origin(origin)
            .maybe_max_time(max_time)
            .inter_arrival_time(inter_arrival_time)
            .build();

        Self {
            primary,
            afterpulse,
            secondaries: Vec::new(),
        }
    }
}

impl<F, I1, B, I2, S: State> PrimaryGenerator<F, I1, B, I2>
where
    F: PartialOrd + for<'a> Add<&'a F, Output = F> + Clone,
    I1: PositiveIterator<Item = F>,
    B: FnMut(&WireEvent<F>) -> SecondaryGeneratorBuilder<F, I2, S>,
    I2: PositiveIterator<Item = F>,
    S::Source: IsSet,
    S::Origin: IsUnset,
    S::InterArrivalTime: IsSet,
{
    fn next_primary(&mut self) -> Option<WireEvent<F>> {
        if let Some(next_event) = self.primary.next_event() {
            let generator = (self.afterpulse)(&next_event)
                .origin(next_event.time.clone())
                .build();
            if generator.next_time.is_some() {
                self.secondaries.push(generator);
            }

            Some(next_event)
        } else {
            None
        }
    }

    fn next_secondary(&mut self, index: usize) -> WireEvent<F> {
        let next_event = self.secondaries[index].next_event();
        if self.secondaries[index].next_time.is_none() {
            self.secondaries.swap_remove(index);
        }

        next_event.unwrap()
    }
}

use secondary_generator_builder::{IsSet, IsUnset, State};

impl<F, I1, B, I2, S: State> EventGenerator for PrimaryGenerator<F, I1, B, I2>
where
    F: PartialOrd + for<'a> Add<&'a F, Output = F> + Clone,
    I1: PositiveIterator<Item = F>,
    B: FnMut(&WireEvent<F>) -> SecondaryGeneratorBuilder<F, I2, S>,
    I2: PositiveIterator<Item = F>,
    S::Source: IsSet,
    S::Origin: IsUnset,
    S::InterArrivalTime: IsSet,
{
    type Time = F;

    fn next_event(&mut self) -> Option<WireEvent<Self::Time>> {
        if let Some(index) = self
            .secondaries
            .iter()
            .enumerate()
            .min_by(|(_, a), (_, b)| {
                // Unwrap is safe because (given the PositiveIterator trait) we
                // don't have NaNs.
                a.next_time.partial_cmp(&b.next_time).unwrap()
            })
            .map(|(i, _)| i)
        {
            if let Some(next_primary) = &self.primary.next_time {
                if next_primary < self.secondaries[index].next_time.as_ref().unwrap() {
                    self.next_primary()
                } else {
                    Some(self.next_secondary(index))
                }
            } else {
                Some(self.next_secondary(index))
            }
        } else {
            self.next_primary()
        }
    }
}

impl<F, I1, B, I2, S: State> Iterator for PrimaryGenerator<F, I1, B, I2>
where
    F: PartialOrd + for<'a> Add<&'a F, Output = F> + Clone,
    I1: PositiveIterator<Item = F>,
    B: FnMut(&WireEvent<F>) -> SecondaryGeneratorBuilder<F, I2, S>,
    I2: PositiveIterator<Item = F>,
    S::Source: IsSet,
    S::Origin: IsUnset,
    S::InterArrivalTime: IsSet,
{
    type Item = WireEvent<F>;

    fn next(&mut self) -> Option<Self::Item> {
        self.next_event()
    }
}
*/

#[cfg(test)]
mod tests {
    use super::*;
    use std::iter::repeat;

    #[test]
    fn positive_new() {
        assert_eq!(Positive::new(0.0), None);
        assert_eq!(Positive::new(-1.0), None);
        assert_eq!(Positive::new(1.0), Some(Positive(1.0)));
    }

    #[test]
    fn secondary_generator_source() {
        let gen = SecondaryGenerator::builder()
            .source(Source::Noise)
            .origin(0.0)
            .inter_arrival_time(vec![Positive::new(1.0).unwrap()])
            .build();

        for event in gen {
            assert!(matches!(event.source, Source::Noise));
        }
    }

    #[test]
    fn secondary_generator_origin() {
        let mut gen = SecondaryGenerator::builder()
            .source(Source::Noise)
            .origin(-10.0)
            .inter_arrival_time(vec![Positive::new(1.0).unwrap()])
            .build();

        assert_eq!(gen.next().unwrap().time, -9.0);
    }

    #[test]
    fn secondary_generator_duration() {
        let events = SecondaryGenerator::builder()
            .source(Source::Noise)
            .origin(0.0)
            .duration(Positive::new(10.0).unwrap())
            .inter_arrival_time(repeat(Positive::new(1.0).unwrap()))
            .build()
            .collect::<Vec<_>>();

        assert_eq!(events.last().unwrap().time, 9.0);
    }

    #[test]
    fn secondary_generator_inter_arrival_time() {
        let mut gen = SecondaryGenerator::builder()
            .source(Source::Noise)
            .origin(0.0)
            .inter_arrival_time(vec![
                Positive::new(1.0).unwrap(),
                Positive::new(2.0).unwrap(),
            ])
            .build();

        assert_eq!(gen.next().unwrap().time, 1.0);
        assert_eq!(gen.next().unwrap().time, 3.0);
        assert!(gen.next().is_none());
    }
}
