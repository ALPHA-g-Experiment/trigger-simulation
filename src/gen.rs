use bon::bon;
pub use num_traits::identities::Zero;
use std::iter::{zip, Peekable, Zip};
use std::ops::Add;
use std::str::FromStr;

/// The source of a [`WireEvent`].
#[derive(Clone, Copy, Debug)]
pub enum Source {
    /// The first avalanche from a cosmic event.
    PrimaryCosmic,
    /// Secondary avalanches in a cosmic event. Generated by electrons
    /// originally produced in the drift region of the rTPC.
    SecondaryCosmic,
    /// The first avalanche from an anti-proton event.
    PrimaryPbar,
    /// Secondary avalanches in an anti-proton event. Generated by electrons
    /// originally produced in the drift region of the rTPC.
    SecondaryPbar,
    /// Noise events.
    Noise,
}

/// Anode wires pattern.
///
/// There are 256 anode wires grouped into 16 boards (each with 16 consecutive
/// wires). A [`WirePattern`] represents the high/low state of all 16 boards.
/// A board is considered to be high if any of its wires is over threshold.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct WirePattern(pub(crate) u16);

impl WirePattern {
    /// Create a new [`WirePattern`] from a bit pattern. Each bit represents the
    /// state of a board.
    ///
    /// # Example
    ///
    /// ```
    /// # use trg::gen::WirePattern;
    /// // Only one board is high (the second one from the left).
    /// //
    /// // Any number of wires in that board can be over the trigger threshold,
    /// // but the pattern seen by the trigger system is the same.
    /// let pattern = WirePattern::from_bits(0b0100000000000000);
    /// ```
    pub fn from_bits(bits: u16) -> Self {
        Self(bits)
    }
}

impl FromStr for WirePattern {
    type Err = std::num::ParseIntError;

    /// Convert a string slice in base 2 to a [`WirePattern`].
    ///
    /// # Example
    /// ```
    /// # use trg::gen::WirePattern;
    /// let pattern = "0100000000000000".parse::<WirePattern>()?;
    /// let expected = WirePattern::from_bits(0b0100000000000000);
    ///
    /// assert_eq!(pattern, expected);
    /// # Ok::<(), std::num::ParseIntError>(())
    /// ```
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let bits = u16::from_str_radix(s, 2)?;
        Ok(Self(bits))
    }
}

/// A [`WireEvent`] represents an input signal to the trigger system.
///
/// The digitized anode wire waveforms go into digital discriminators. This
/// discriminator outputs ([`WireEvent`]s) are then sent to the trigger system.
#[derive(Clone, Copy, Debug)]
pub struct WireEvent<F> {
    /// The source of the event.
    pub source: Source,
    /// Anode wire preamp pattern.
    pub wire_pattern: WirePattern,
    /// Time of the event.
    pub time: F,
}

/// A value that is known to be greater than zero.
#[derive(Clone, Copy, Debug, PartialEq, PartialOrd)]
pub struct Positive<F>(F);

impl<F> Positive<F>
where
    F: Zero + PartialOrd,
{
    pub fn new(value: F) -> Option<Self> {
        if value > F::zero() {
            Some(Self(value))
        } else {
            None
        }
    }
}

mod sealed {
    pub trait OrderedIterator: Iterator {}
}

/// Generator of [`WireEvent`]s.
///
/// Events are guaranteed to be produced in increasing order of time.
pub trait EventGenerator: sealed::OrderedIterator<Item = WireEvent<Self::Time>> {
    type Time;
}

impl<T, G> EventGenerator for G
where
    G: sealed::OrderedIterator<Item = WireEvent<T>>,
{
    type Time = T;
}

/// A trait for dealing with iterators that produce positive values.
pub trait PositiveIterator: Iterator<Item = Positive<Self::Type>> {
    type Type;
}

impl<T, I: Iterator<Item = Positive<T>>> PositiveIterator for I {
    type Type = T;
}

/// A generator of [`WireEvent`]s without afterpulses.
///
/// The generator produces a stream of [`WireEvent`]s all with the same
/// [`Source`]. A generator stops producing events when either the desired
/// duration has been reached, or when the inter-arrival time/wire pattern
/// distributions have been exhausted.
#[derive(Clone, Debug)]
pub struct SecondaryGenerator<I, P>
where
    I: PositiveIterator,
{
    source: Source,
    current_time: Option<I::Type>,
    max_time: Option<I::Type>,
    // (time, wire_pattern)
    iter: Zip<I, P>,
}

#[bon]
impl<I, P> SecondaryGenerator<I, P>
where
    I: PositiveIterator,
{
    #[builder]
    pub fn new<T1, T2>(
        /// The source of the generated events.
        source: Source,
        /// The time at which the generator starts producing events. Note that
        /// the first event is produced at `origin` + `delta_t`, where `delta_t`
        /// is the first value produced by `inter_arrival_time`.
        origin: I::Type,
        /// Length of time the generator produces events for. All events are
        /// guaranteed to have a time less than `origin` + `duration`.
        duration: Option<Positive<I::Type>>,
        /// The distribution of inter-arrival times between events.
        inter_arrival_time: T1,
        /// The distribution of wire patterns.
        wire_pattern: T2,
    ) -> Self
    where
        T1: IntoIterator<IntoIter = I>,
        T2: IntoIterator<IntoIter = P>,
        // Another alternative could be
        // `I::Type: for<'a> Add<&'a I::Type, Output = I::Type>` instead.
        // But:
        // 1. `impl Iterator` requires `I::Type: Clone` anyway.
        // 2. I want to use `Quantity` types from the `uom` crate, and these
        // don't implement `Add<&T, Output = T>` yet (maybe soon they will).
        I::Type: Add<I::Type, Output = I::Type> + Clone,
    {
        Self {
            source,
            current_time: Some(origin.clone()),
            max_time: duration.map(|Positive(t)| t + origin),
            iter: zip(inter_arrival_time, wire_pattern),
        }
    }
}

impl<I, P> Iterator for SecondaryGenerator<I, P>
where
    I: PositiveIterator,
    I::Type: Add<I::Type, Output = I::Type> + Clone + PartialOrd,
    P: Iterator<Item = WirePattern>,
{
    type Item = WireEvent<I::Type>;

    fn next(&mut self) -> Option<Self::Item> {
        match (self.current_time.take(), self.iter.next()) {
            (None, _) => None,
            (_, None) => None,
            (Some(time), Some((Positive(delta_t), wire_pattern))) => {
                let time = time + delta_t;
                if let Some(max_time) = &self.max_time {
                    if time < *max_time {
                        self.current_time = Some(time.clone());
                    } else {
                        return None;
                    }
                } else {
                    self.current_time = Some(time.clone());
                }

                Some(WireEvent {
                    source: self.source,
                    wire_pattern,
                    time,
                })
            }
        }
    }
}

impl<I, P> sealed::OrderedIterator for SecondaryGenerator<I, P>
where
    I: PositiveIterator,
    I::Type: Add<I::Type, Output = I::Type> + Clone + PartialOrd,
    P: Iterator<Item = WirePattern>,
{
}

/// A generator of [`WireEvent`]s with afterpulses.
///
/// The generator produces a stream of [`WireEvent`]s in increasing order of
/// time. Each primary event triggers a set of secondary events. The generator
/// stops when all primary and secondary events have been produced.
pub struct PrimaryGenerator<I1, P1, B, I2, P2>
where
    I1: PositiveIterator,
    I1::Type: Add<I1::Type, Output = I1::Type> + Clone + PartialOrd,
    P1: Iterator<Item = WirePattern>,
    I2: PositiveIterator<Type = I1::Type>,
    P2: Iterator<Item = WirePattern>,
{
    primary: Peekable<SecondaryGenerator<I1, P1>>,
    afterpulse: B,
    secondaries: Vec<Peekable<SecondaryGenerator<I2, P2>>>,
}

// The Derive macro is not smart enough to implement Clone in this case.
impl<I1: Clone, P1: Clone, B: Clone, I2: Clone, P2: Clone> Clone
    for PrimaryGenerator<I1, P1, B, I2, P2>
where
    I1: PositiveIterator,
    I1::Type: Add<I1::Type, Output = I1::Type> + Clone + PartialOrd,
    P1: Iterator<Item = WirePattern>,
    I2: PositiveIterator<Type = I1::Type>,
    P2: Iterator<Item = WirePattern>,
{
    fn clone(&self) -> Self {
        Self {
            primary: self.primary.clone(),
            afterpulse: self.afterpulse.clone(),
            secondaries: self.secondaries.clone(),
        }
    }
}

#[bon]
impl<I1, P1, B, I2, P2> PrimaryGenerator<I1, P1, B, I2, P2>
where
    I1: PositiveIterator,
    I1::Type: Add<I1::Type, Output = I1::Type> + Clone + PartialOrd,
    P1: Iterator<Item = WirePattern>,
    I2: PositiveIterator<Type = I1::Type>,
    P2: Iterator<Item = WirePattern>,
{
    #[builder]
    pub fn new<T1, T2>(
        /// The source of the primary events.
        source: Source,
        /// The time at which the generator starts producing events. Note that
        /// the first event is produced at `origin` + `delta_t`, where `delta_t`
        /// is the first value produced by `inter_arrival_time`.
        origin: I1::Type,
        /// Length of time the generator produces primary events for. Note that
        /// the generator will keep producing secondary events until all
        /// secondary generators have also been exhausted (which could be after
        /// the primary generator has stopped producing events).
        duration: Option<Positive<I1::Type>>,
        /// The distribution of inter-arrival times between primary events.
        inter_arrival_time: T1,
        /// The distribution of wire patterns for primary events.
        wire_pattern: T2,
        /// Secondary generator builder.
        ///
        /// The `origin` of the secondary generator is automatically set to the
        /// time of the primary event that triggered it.
        afterpulse: B,
    ) -> Self
    where
        T1: IntoIterator<IntoIter = I1>,
        T2: IntoIterator<IntoIter = P1>,
    {
        let primary = SecondaryGenerator::builder()
            .source(source)
            .origin(origin)
            .maybe_duration(duration)
            .inter_arrival_time(inter_arrival_time)
            .wire_pattern(wire_pattern)
            .build()
            .peekable();

        Self {
            primary,
            afterpulse,
            secondaries: Vec::new(),
        }
    }
}

use secondary_generator_builder::{IsSet, IsUnset, State};

impl<I1, P1, B, I2, P2, T3, T4, S: State> PrimaryGenerator<I1, P1, B, I2, P2>
where
    I1: PositiveIterator,
    I1::Type: Add<I1::Type, Output = I1::Type> + Clone + PartialOrd,
    P1: Iterator<Item = WirePattern>,
    I2: PositiveIterator<Type = I1::Type>,
    P2: Iterator<Item = WirePattern>,
    B: FnMut(&WireEvent<I1::Type>) -> SecondaryGeneratorBuilder<I2, P2, T3, T4, S>,
    T3: IntoIterator<IntoIter = I2>,
    T4: IntoIterator<IntoIter = P2>,
    S::Source: IsSet,
    S::Origin: IsUnset,
    S::InterArrivalTime: IsSet,
    S::WirePattern: IsSet,
{
    fn next_primary(&mut self) -> Option<WireEvent<I1::Type>> {
        if let Some(next_event) = self.primary.next() {
            let mut generator = (self.afterpulse)(&next_event)
                .origin(next_event.time.clone())
                .build()
                .peekable();
            // Only keep around secondary generators that have something to
            // produce.
            if generator.peek().is_some() {
                self.secondaries.push(generator);
            }

            Some(next_event)
        } else {
            None
        }
    }

    fn next_secondary(&mut self, index: usize) -> Option<WireEvent<I1::Type>> {
        let next_event = self.secondaries[index].next();
        if self.secondaries[index].peek().is_none() {
            let _ = self.secondaries.swap_remove(index);
        }

        next_event
    }
}

impl<I1, P1, B, I2, P2, T3, T4, S: State> Iterator for PrimaryGenerator<I1, P1, B, I2, P2>
where
    I1: PositiveIterator,
    I1::Type: Add<I1::Type, Output = I1::Type> + Clone + PartialOrd,
    P1: Iterator<Item = WirePattern>,
    I2: PositiveIterator<Type = I1::Type>,
    P2: Iterator<Item = WirePattern>,
    B: FnMut(&WireEvent<I1::Type>) -> SecondaryGeneratorBuilder<I2, P2, T3, T4, S>,
    T3: IntoIterator<IntoIter = I2>,
    T4: IntoIterator<IntoIter = P2>,
    S::Source: IsSet,
    S::Origin: IsUnset,
    S::InterArrivalTime: IsSet,
    S::WirePattern: IsSet,
{
    type Item = WireEvent<I1::Type>;

    fn next(&mut self) -> Option<Self::Item> {
        if let Some((index, next_secondary)) = self
            .secondaries
            .iter_mut()
            // We only keep around generators that will return `Some`.
            .map(|g| g.peek().unwrap())
            .enumerate()
            // No `NaN` values because of the `PositiveIterator` bound.
            .min_by(|(_, a), (_, b)| a.time.partial_cmp(&b.time).unwrap())
        {
            if let Some(next_primary) = self.primary.peek() {
                if next_primary.time < next_secondary.time {
                    self.next_primary()
                } else {
                    self.next_secondary(index)
                }
            } else {
                self.next_secondary(index)
            }
        } else {
            self.next_primary()
        }
    }
}

impl<I1, P1, B, I2, P2, T3, T4, S: State> sealed::OrderedIterator
    for PrimaryGenerator<I1, P1, B, I2, P2>
where
    I1: PositiveIterator,
    I1::Type: Add<I1::Type, Output = I1::Type> + Clone + PartialOrd,
    P1: Iterator<Item = WirePattern>,
    I2: PositiveIterator<Type = I1::Type>,
    P2: Iterator<Item = WirePattern>,
    B: FnMut(&WireEvent<I1::Type>) -> SecondaryGeneratorBuilder<I2, P2, T3, T4, S>,
    T3: IntoIterator<IntoIter = I2>,
    T4: IntoIterator<IntoIter = P2>,
    S::Source: IsSet,
    S::Origin: IsUnset,
    S::InterArrivalTime: IsSet,
    S::WirePattern: IsSet,
{
}

type InnerGen<T> = Box<dyn EventGenerator<Time = T, Item = WireEvent<T>>>;

/// A generator of [`WireEvent`]s.
///
/// A [`Generator`] can be composed of multiple [`EventGenerator`]s and produces
/// a stream of [`WireEvent`]s in increasing order of time. The generator stops
/// when all of its constituent generators have been exhausted.
#[derive(bon::Builder)]
pub struct Generator<T> {
    #[builder(field)]
    gens: Vec<Peekable<InnerGen<T>>>,
}

impl<T, S: generator_builder::State> GeneratorBuilder<T, S> {
    /// Add an event generator to the [`Generator`].
    pub fn add_generator<G>(mut self, gen: G) -> Self
    where
        G: EventGenerator<Time = T> + 'static,
    {
        let mut peekable = (Box::new(gen) as InnerGen<T>).peekable();
        // Only keep around useful generators.
        if peekable.peek().is_some() {
            self.gens.push(peekable);
        }
        self
    }
}

impl<T: PartialOrd> Iterator for Generator<T> {
    type Item = WireEvent<T>;

    fn next(&mut self) -> Option<Self::Item> {
        let (index, _) = self
            .gens
            .iter_mut()
            // Safe to unwrap because we only keep useful generators.
            .map(|g| g.peek().unwrap())
            .enumerate()
            .min_by(|(_, a), (_, b)| a.time.partial_cmp(&b.time).unwrap())?;

        let next_event = self.gens[index].next();
        if self.gens[index].peek().is_none() {
            let _ = self.gens.swap_remove(index);
        }

        next_event
    }
}

impl<T: PartialOrd> sealed::OrderedIterator for Generator<T> {}

#[cfg(test)]
mod tests {
    use super::*;
    use std::iter::repeat;

    #[test]
    fn positive_new() {
        assert_eq!(Positive::new(0.0), None);
        assert_eq!(Positive::new(-1.0), None);
        assert_eq!(Positive::new(1.0), Some(Positive(1.0)));
    }

    #[test]
    fn wire_pattern() {
        let a = WirePattern::from_bits(0b1000000000000000);
        let b = "1000000000000000".parse::<WirePattern>().unwrap();

        assert_eq!(a, b);
        assert_eq!(a, WirePattern(32768));
    }

    #[test]
    fn secondary_generator_source() {
        let gen = SecondaryGenerator::builder()
            .source(Source::Noise)
            .origin(0.0)
            .inter_arrival_time(vec![Positive::new(1.0).unwrap()])
            .wire_pattern(vec![WirePattern::from_bits(0)])
            .build();

        for event in gen {
            assert!(matches!(event.source, Source::Noise));
        }
    }

    #[test]
    fn secondary_generator_origin() {
        let mut gen = SecondaryGenerator::builder()
            .source(Source::Noise)
            .origin(-10.0)
            .inter_arrival_time(vec![Positive::new(1.0).unwrap()])
            .wire_pattern(vec![WirePattern::from_bits(0)])
            .build();

        assert_eq!(gen.next().unwrap().time, -9.0);
    }

    #[test]
    fn secondary_generator_duration() {
        let events = SecondaryGenerator::builder()
            .source(Source::Noise)
            .origin(0.0)
            .duration(Positive::new(10.0).unwrap())
            .inter_arrival_time(repeat(Positive::new(1.0).unwrap()))
            .wire_pattern(repeat(WirePattern::from_bits(0)))
            .build()
            .collect::<Vec<_>>();

        assert_eq!(events.last().unwrap().time, 9.0);
    }

    #[test]
    fn secondary_generator_inter_arrival_time() {
        let mut gen = SecondaryGenerator::builder()
            .source(Source::Noise)
            .origin(0.0)
            .inter_arrival_time(vec![
                Positive::new(1.0).unwrap(),
                Positive::new(2.0).unwrap(),
            ])
            .wire_pattern(repeat(WirePattern::from_bits(0)))
            .build();

        assert_eq!(gen.next().unwrap().time, 1.0);
        assert_eq!(gen.next().unwrap().time, 3.0);
        assert!(gen.next().is_none());
    }

    #[test]
    fn secondary_generator_wire_pattern() {
        let mut gen = SecondaryGenerator::builder()
            .source(Source::Noise)
            .origin(0.0)
            .inter_arrival_time(repeat(Positive::new(1.0).unwrap()))
            .wire_pattern(vec![
                WirePattern::from_bits(0),
                WirePattern::from_bits(u16::MAX),
            ])
            .build();

        assert_eq!(gen.next().unwrap().wire_pattern, WirePattern(0));
        assert_eq!(gen.next().unwrap().wire_pattern, WirePattern(u16::MAX));
        assert!(gen.next().is_none());
    }

    #[test]
    fn primary_generator_source() {
        let mut gen = PrimaryGenerator::builder()
            .source(Source::PrimaryPbar)
            .origin(0.0)
            .inter_arrival_time(vec![Positive::new(1.0).unwrap()])
            .wire_pattern(vec![WirePattern::from_bits(0)])
            .afterpulse(|_: &_| {
                SecondaryGenerator::builder()
                    .source(Source::SecondaryPbar)
                    .inter_arrival_time(vec![Positive::new(1.0).unwrap()])
                    .wire_pattern(vec![WirePattern::from_bits(0)])
            })
            .build();

        assert!(matches!(gen.next().unwrap().source, Source::PrimaryPbar));
        assert!(matches!(gen.next().unwrap().source, Source::SecondaryPbar));
    }

    #[test]
    fn primary_generator_origin() {
        let mut gen = PrimaryGenerator::builder()
            .source(Source::PrimaryPbar)
            .origin(0.0)
            .inter_arrival_time(vec![Positive::new(1.0).unwrap()])
            .wire_pattern(vec![WirePattern::from_bits(0)])
            .afterpulse(|_: &_| {
                SecondaryGenerator::builder()
                    .source(Source::SecondaryPbar)
                    .inter_arrival_time(vec![Positive::new(1.0).unwrap()])
                    .wire_pattern(vec![WirePattern::from_bits(0)])
            })
            .build();

        assert_eq!(gen.next().unwrap().time, 1.0);
    }

    #[test]
    fn primary_generator_duration() {
        let events = PrimaryGenerator::builder()
            .source(Source::PrimaryPbar)
            .origin(0.0)
            .duration(Positive::new(10.0).unwrap())
            .inter_arrival_time(repeat(Positive::new(1.0).unwrap()))
            .wire_pattern(repeat(WirePattern::from_bits(0)))
            .afterpulse(|_: &_| {
                SecondaryGenerator::builder()
                    .source(Source::SecondaryPbar)
                    .inter_arrival_time(vec![Positive::new(1.0).unwrap()])
                    .wire_pattern(vec![WirePattern::from_bits(0)])
            })
            .build()
            .collect::<Vec<_>>();

        assert_eq!(
            events
                .iter()
                .filter(|e| matches!(e.source, Source::PrimaryPbar))
                .last()
                .unwrap()
                .time,
            9.0
        );
        assert_eq!(events.last().unwrap().time, 10.0);
    }

    #[test]
    fn primary_generator_inter_arrival_time() {
        let mut gen = PrimaryGenerator::builder()
            .source(Source::PrimaryPbar)
            .origin(0.0)
            .inter_arrival_time(vec![
                Positive::new(1.0).unwrap(),
                Positive::new(2.0).unwrap(),
            ])
            .wire_pattern(repeat(WirePattern::from_bits(0)))
            .afterpulse(|_: &_| {
                SecondaryGenerator::builder()
                    .source(Source::SecondaryPbar)
                    .inter_arrival_time(vec![Positive::new(0.1).unwrap()])
                    .wire_pattern(vec![WirePattern::from_bits(0)])
            })
            .build();

        assert_eq!(gen.next().unwrap().time, 1.0);
        assert_eq!(gen.next().unwrap().time, 1.1);
        assert_eq!(gen.next().unwrap().time, 3.0);
        assert_eq!(gen.next().unwrap().time, 3.1);
        assert!(gen.next().is_none());
    }

    #[test]
    fn primary_generator_wire_pattern() {
        let mut gen = PrimaryGenerator::builder()
            .source(Source::PrimaryPbar)
            .origin(0.0)
            .inter_arrival_time(repeat(Positive::new(2.0).unwrap()))
            .wire_pattern(vec![WirePattern::from_bits(0), WirePattern::from_bits(0)])
            .afterpulse(|_: &_| {
                SecondaryGenerator::builder()
                    .source(Source::SecondaryPbar)
                    .inter_arrival_time(repeat(Positive::new(1.0).unwrap()))
                    .wire_pattern(vec![WirePattern::from_bits(u16::MAX)])
            })
            .build();

        assert_eq!(gen.next().unwrap().wire_pattern, WirePattern(0));
        assert_eq!(gen.next().unwrap().wire_pattern, WirePattern(u16::MAX));
        assert_eq!(gen.next().unwrap().wire_pattern, WirePattern(0));
        assert_eq!(gen.next().unwrap().wire_pattern, WirePattern(u16::MAX));
        assert!(gen.next().is_none());
    }

    #[test]
    fn primary_generator_afterpulse() {
        let mut count = 0;

        let mut gen = PrimaryGenerator::builder()
            .source(Source::PrimaryPbar)
            .origin(0.0)
            .inter_arrival_time(repeat(Positive::new(1.0).unwrap()).take(3))
            .wire_pattern(repeat(WirePattern::from_bits(0)))
            .afterpulse(|_: &_| {
                let n = count;
                let delta_t = 1.0 / (n + 1) as f64;
                count += 1;

                SecondaryGenerator::builder()
                    .source(Source::SecondaryPbar)
                    .inter_arrival_time(repeat(Positive::new(delta_t).unwrap()).take(n))
                    .wire_pattern(repeat(WirePattern::from_bits(0)))
            })
            .build();

        assert!((gen.next().unwrap().time - 1.0).abs() < 1e-6);
        assert!((gen.next().unwrap().time - 2.0).abs() < 1e-6);
        assert!((gen.next().unwrap().time - 2.5).abs() < 1e-6);
        assert!((gen.next().unwrap().time - 3.0).abs() < 1e-6);
        assert!((gen.next().unwrap().time - 10.0 / 3.0).abs() < 1e-6);
        assert!((gen.next().unwrap().time - 11.0 / 3.0).abs() < 1e-6);
        assert!(gen.next().is_none());
    }

    #[test]
    fn generator() {
        let primary_gen = PrimaryGenerator::builder()
            .source(Source::PrimaryPbar)
            .origin(0.0)
            .inter_arrival_time(vec![Positive::new(1.0).unwrap()])
            .wire_pattern(vec![WirePattern::from_bits(0)])
            .afterpulse(|_: &_| {
                SecondaryGenerator::builder()
                    .source(Source::SecondaryPbar)
                    .inter_arrival_time(vec![Positive::new(2.0).unwrap()])
                    .wire_pattern(vec![WirePattern::from_bits(0)])
            })
            .build();
        let secondary_gen = SecondaryGenerator::builder()
            .source(Source::Noise)
            .origin(-10.0)
            .duration(Positive::new(25.0).unwrap())
            .inter_arrival_time(repeat(Positive::new(10.0).unwrap()))
            .wire_pattern(repeat(WirePattern::from_bits(0)))
            .build();

        let mut gen = Generator::builder()
            .add_generator(primary_gen)
            .add_generator(secondary_gen)
            .build();

        assert_eq!(gen.next().unwrap().time, 0.0);
        assert_eq!(gen.next().unwrap().time, 1.0);
        assert_eq!(gen.next().unwrap().time, 3.0);
        assert_eq!(gen.next().unwrap().time, 10.0);
        assert!(gen.next().is_none());
    }
}
